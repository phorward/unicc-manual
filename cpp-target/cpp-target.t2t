
+ C++ parser target +[stdcppparser]

The C++ target is a fork of the [C parser target #stdcparser], and allows to compile into C++ source files.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------

++ Overview ++

For now, input processing is done in the same way as in the C target, but this may be changed in the future. Because the C++ target is a fork of the C target, all macros and features from there should also work here. The major difference between the C and the C++ target is, that latter one emits classes.

Generated parsers in the C++ should behave like parsers for the C target. They use the same algorithms for input caching, so that characters are requested only once from the input source. Input source can be anything that emits characters.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------

++ Features ++

Parsers generated by the C++ target so far provide

- Established on C++ standard library
- Thread-safe, parsers can recursively be called
- Automatic construction of an AST data structure when [abstract syntax tree notation #ref_ast] is provided
- Provides a default parser test environment if no semantic code is given
- Dynamic end-of-file behavior
-

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------

++ Contributions ++

Any contributions to the parser target are welcome. Contributions can be sent to us, so we will integrate them into the distribution version of UniCC and the standard template, if they are necessary and useful for everyone.

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------

++ Example with semantic actions ++

The Python target is currently not covered in detail, so only a short example is presented. For now, it is important that the correct indention level is satisfied, which is a dependency for Python. The [AST notations #ref_ast] introduced with UniCC v1.3 and higher integrate perfectly with the Python target.

%!include: ``expr.cpp.par``

Compile and run it with

```
unicc expr.cpp.par
g++ -o expr expr.cpp.cpp
```

%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------
%-------------------------------------------------------------------------------

++ Classes ++

Right now, the C++ targets emits only the class **@@prefix_parser**, which behaves as the [parser control block #pcb] from the C target, but encapsulates all functions a private and public members. The object can be referenced in any semantic actions with the ``this`` keyword.

Any other data objects known from the C target are remaining as public structures without any object-oriented aspects.
